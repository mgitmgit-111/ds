<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DS DS DS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: #ffffff;
            color: #000000;
            line-height: 1.6;
        }

        header {
            background-color: #000000;
            color: #ffffff;
            padding: 30px 20px;
            text-align: center;
            border-bottom: 2px solid #000000;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        header p {
            font-size: 0.95em;
            opacity: 0.9;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        .search-section {
            margin-bottom: 40px;
        }

        .search-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .search-input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #000000;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            background-color: #ffffff;
            color: #000000;
        }

        .search-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);
        }

        .filter-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .filter-btn {
            padding: 10px 15px;
            border: 2px solid #000000;
            background-color: #ffffff;
            color: #000000;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .filter-btn:hover {
            background-color: #000000;
            color: #ffffff;
        }

        .filter-btn.active {
            background-color: #000000;
            color: #ffffff;
        }

        .code-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .code-card {
            border: 2px solid #000000;
            background-color: #ffffff;
            padding: 0;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        .code-card:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .card-header {
            background-color: #000000;
            color: #ffffff;
            padding: 15px;
            border-bottom: 2px solid #000000;
        }

        .card-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .card-meta {
            font-size: 0.85em;
            opacity: 0.85;
            display: flex;
            gap: 10px;
        }

        .card-meta span {
            padding: 3px 8px;
            background-color: #ffffff;
            color: #000000;
            border-radius: 3px;
        }

        .card-description {
            padding: 10px 15px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 0.9em;
            color: #333333;
        }

        .card-code {
            flex: 1;
            padding: 15px;
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            overflow-x: auto;
            max-height: 300px;
            overflow-y: auto;
        }

        .card-code code {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.4;
            color: #000000;
        }

        .card-footer {
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 10px;
        }

        .copy-btn {
            flex: 1;
            padding: 10px 15px;
            background-color: #000000;
            color: #ffffff;
            border: 2px solid #000000;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background-color: #ffffff;
            color: #000000;
        }

        .copy-btn.copied {
            background-color: #ffffff;
            color: #000000;
        }

        .no-results {
            text-align: center;
            padding: 40px 20px;
            font-size: 1.1em;
            color: #666666;
        }

        .results-count {
            margin-bottom: 20px;
            font-size: 0.95em;
            color: #666666;
        }

        @media (max-width: 768px) {
            .code-grid {
                grid-template-columns: 1fr;
            }

            header h1 {
                font-size: 1.8em;
            }

            .search-bar {
                flex-direction: column;
            }
        }

        /* Scrollbar styling */
        .card-code::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .card-code::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .card-code::-webkit-scrollbar-thumb {
            background: #888;
        }

        .card-code::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <header>
        <h1>CODE SNIPPETS</h1>
        <p>Jaldiii copy paste</p>
    </header>

    <div class="container">
        <div class="search-section">
            <div class="search-bar">
                <input 
                    type="text" 
                    id="searchInput" 
                    class="search-input" 
                    placeholder="Search by title, category, or description..."
                    autocomplete="off"
                >
            </div>

            <div class="filter-buttons">
                <button class="filter-btn active" data-filter="all">ALL</button>
                <button class="filter-btn" data-filter="data-structures">DATA STRUCTURES</button>
                <button class="filter-btn" data-filter="sorting-algorithms">SORTING</button>
                <button class="filter-btn" data-filter="stack-queue">STACK & QUEUE</button>
                <button class="filter-btn" data-filter="graph-algorithms">GRAPHS</button>
                <button class="filter-btn" data-filter="string-algorithms">STRINGS</button>
            </div>

            <div class="results-count" id="resultsCount"></div>
        </div>

        <div class="code-grid" id="codeGrid"></div>
        <div class="no-results" id="noResults" style="display: none;">No codes match your search.</div>
    </div>

    <script>
        const codesData = {
            "1.A": {
                "title": "Singly Linked List Operations",
                "category": "Data Structures",
                "language": "c",
                "description": "Creation, Insertion, Deletion, Traversal",
                "code": `#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function for creation (insert at end to build list)
struct Node* insertAtEnd(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    if (head == NULL) {
        return newNode;
    }
    struct Node* temp = head;
    while (temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newNode;
    return head;
}

// Function for insertion (at beginning)
struct Node* insertAtBeginning(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    newNode->next = head;
    return newNode;
}

// Function for deletion (by value)
struct Node* deleteNode(struct Node* head, int key) {
    if (head == NULL) return head;
    if (head->data == key) {
        struct Node* temp = head;
        head = head->next;
        free(temp);
        return head;
    }
    struct Node* temp = head;
    while (temp->next != NULL && temp->next->data != key) {
        temp = temp->next;
    }
    if (temp->next != NULL) {
        struct Node* toDelete = temp->next;
        temp->next = toDelete->next;
        free(toDelete);
    }
    return head;
}

// Function for traversal
void traverse(struct Node* head) {
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// Main function to demonstrate
int main() {
    struct Node* head = NULL;

    // Creation: Insert multiple nodes
    head = insertAtEnd(head, 10);
    head = insertAtEnd(head, 20);
    head = insertAtEnd(head, 30);

    printf("After Creation: ");
    traverse(head);

    // Insertion at beginning
    head = insertAtBeginning(head, 5);
    printf("After Insertion at Beginning: ");
    traverse(head);

    // Deletion
    head = deleteNode(head, 20);
    printf("After Deletion of 20: ");
    traverse(head);

    return 0;
}`
            },
            "1.B": {
                "title": "Merge Sort",
                "category": "Sorting Algorithms",
                "language": "c",
                "description": "Divide and conquer sorting algorithm",
                "code": `#include <stdio.h>
#include <stdlib.h>

// Merge two sorted halves
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int* L = (int*)malloc(n1 * sizeof(int));
    int* R = (int*)malloc(n2 * sizeof(int));

    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }
    while (i < n1) {
        arr[k++] = L[i++];
    }
    while (j < n2) {
        arr[k++] = R[j++];
    }

    free(L);
    free(R);
}

// Recursive merge sort
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        merge(arr, left, mid, right);
    }
}

// Main function
int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Original array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");

    mergeSort(arr, 0, n - 1);

    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");

    return 0;
}`
            },
            "2.A": {
                "title": "Infix to Postfix Conversion",
                "category": "Stack & Queue",
                "language": "c",
                "description": "Using Stack to convert infix expressions to postfix",
                "code": `#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 100

char stack[MAX];
int top = -1;

// Push function
void push(char ch) {
    if (top < MAX - 1) {
        stack[++top] = ch;
    }
}

// Pop function
char pop() {
    if (top >= 0) {
        return stack[top--];
    }
    return '\0';
}

// Precedence
int precedence(char ch) {
    if (ch == '+' || ch == '-') return 1;
    if (ch == '*' || ch == '/') return 2;
    return 0;
}

// Infix to postfix
void infixToPostfix(char* infix, char* postfix) {
    int i = 0, j = 0;
    while (infix[i] != '\0') {
        if (infix[i] >= 'A' && infix[i] <= 'Z' || infix[i] >= 'a' && infix[i] <= 'z') {
            postfix[j++] = infix[i++];
        } else if (infix[i] == '(') {
            push(infix[i++]);
        } else if (infix[i] == ')') {
            while (top >= 0 && stack[top] != '(') {
                postfix[j++] = pop();
            }
            if (top >= 0) pop(); // Pop '('
            i++;
        } else {
            while (top >= 0 && precedence(stack[top]) >= precedence(infix[i])) {
                postfix[j++] = pop();
            }
            push(infix[i++]);
        }
    }
    while (top >= 0) {
        postfix[j++] = pop();
    }
    postfix[j] = '\0';
}

// Main function
int main() {
    char infix[] = "A+B*C-D/E";
    char postfix[100];

    infixToPostfix(infix, postfix);
    printf("Infix: %s\n", infix);
    printf("Postfix: %s\n", postfix);

    return 0;
}`
            },
            "2.B": {
                "title": "Quick Sort",
                "category": "Sorting Algorithms",
                "language": "c",
                "description": "Efficient divide and conquer sorting",
                "code": `#include <stdio.h>

// Partition function
int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}

// Recursive quick sort
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Main function
int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Original array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");

    quickSort(arr, 0, n - 1);

    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");

    return 0;
}`
            },
            "3.A": {
                "title": "Stack Using Arrays",
                "category": "Stack & Queue",
                "language": "c",
                "description": "Basic stack implementation with array",
                "code": `#include <stdio.h>
#define MAX 100

int stack[MAX];
int top = -1;

// Push function
void push(int data) {
    if (top < MAX - 1) {
        stack[++top] = data;
        printf("%d pushed to stack\n", data);
    } else {
        printf("Stack Overflow\n");
    }
}

// Pop function
int pop() {
    if (top >= 0) {
        int data = stack[top--];
        printf("%d popped from stack\n", data);
        return data;
    } else {
        printf("Stack Underflow\n");
        return -1;
    }
}

// Peek function
int peek() {
    if (top >= 0) {
        return stack[top];
    }
    return -1;
}

// Main function
int main() {
    push(10);
    push(20);
    push(30);
    printf("Top element: %d\n", peek());
    pop();
    printf("Top element after pop: %d\n", peek());
    return 0;
}`
            },
            "3.B": {
                "title": "Heap Sort",
                "category": "Sorting Algorithms",
                "language": "c",
                "description": "Sorting using heap data structure",
                "code": `#include <stdio.h>

// Heapify function
void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;

    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        heapify(arr, n, largest);
    }
}

// Heap sort
void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    for (int i = n - 1; i > 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        heapify(arr, i, 0);
    }
}

// Main function
int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Original array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");

    heapSort(arr, n);

    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", arr[i]);
    printf("\n");

    return 0;
}`
            },
            "4.A": {
                "title": "Stack Using Linked List",
                "category": "Stack & Queue",
                "language": "c",
                "description": "Stack implementation with linked list",
                "code": `#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* next;
};

// Push function
void push(struct Node** top, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = *top;
    *top = newNode;
    printf("%d pushed to stack\n", data);
}

// Pop function
int pop(struct Node** top) {
    if (*top == NULL) {
        printf("Stack Underflow\n");
        return -1;
    }
    struct Node* temp = *top;
    int data = temp->data;
    *top = (*top)->next;
    free(temp);
    printf("%d popped from stack\n", data);
    return data;
}

// Peek function
int peek(struct Node* top) {
    if (top != NULL) {
        return top->data;
    }
    return -1;
}

// Main function
int main() {
    struct Node* top = NULL;
    push(&top, 10);
    push(&top, 20);
    push(&top, 30);
    printf("Top element: %d\n", peek(top));
    pop(&top);
    printf("Top element after pop: %d\n", peek(top));
    return 0;
}`
            },
            "4.B": {
                "title": "BFS Graph Traversal",
                "category": "Graph Algorithms",
                "language": "c",
                "description": "Breadth-First Search traversal",
                "code": `#include <stdio.h>
#include <stdlib.h>
#define MAX 100

// Graph representation using adjacency list
struct Node {
    int vertex;
    struct Node* next;
};

struct Node* head[MAX];

// Add edge
void addEdge(int src, int dest) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->vertex = dest;
    newNode->next = head[src];
    head[src] = newNode;
}

// BFS traversal
void BFS(int start) {
    int visited[MAX] = {0};
    int queue[MAX];
    int front = 0, rear = 0;

    visited[start] = 1;
    queue[rear++] = start;

    while (front < rear) {
        int current = queue[front++];
        printf("%d ", current);

        struct Node* temp = head[current];
        while (temp != NULL) {
            int adjVertex = temp->vertex;
            if (!visited[adjVertex]) {
                visited[adjVertex] = 1;
                queue[rear++] = adjVertex;
            }
            temp = temp->next;
        }
    }
}

// Main function
int main() {
    int V = 5; // Number of vertices

    addEdge(0, 1);
    addEdge(0, 2);
    addEdge(1, 3);
    addEdge(2, 4);

    printf("BFS starting from vertex 0: ");
    BFS(0);
    printf("\n");

    return 0;
}`
            },
            "5.A": {
                "title": "Stack Using Arrays (Duplicate)",
                "category": "Stack & Queue",
                "language": "c",
                "description": "Stack implementation with array",
                "code": `#include <stdio.h>
#define MAX 100

int stack[MAX];
int top = -1;

// Push function
void push(int data) {
    if (top < MAX - 1) {
        stack[++top] = data;
        printf("%d pushed to stack\n", data);
    } else {
        printf("Stack Overflow\n");
    }
}

// Pop function
int pop() {
    if (top >= 0) {
        int data = stack[top--];
        printf("%d popped from stack\n", data);
        return data;
    } else {
        printf("Stack Underflow\n");
        return -1;
    }
}

// Peek function
int peek() {
    if (top >= 0) {
        return stack[top];
    }
    return -1;
}

// Main function
int main() {
    push(10);
    push(20);
    push(30);
    printf("Top element: %d\n", peek());
    pop();
    printf("Top element after pop: %d\n", peek());
    return 0;
}`
            },
            "5.B": {
                "title": "Binary Search Tree Operations",
                "category": "Data Structures",
                "language": "c",
                "description": "Insert, Search, and Inorder Traversal",
                "code": `#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Insert function
struct Node* insert(struct Node* root, int data) {
    if (root == NULL) {
        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
        newNode->data = data;
        newNode->left = newNode->right = NULL;
        return newNode;
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    return root;
}

// Search function
struct Node* search(struct Node* root, int data) {
    if (root == NULL || root->data == data) {
        return root;
    }
    if (data < root->data) {
        return search(root->left, data);
    }
    return search(root->right, data);
}

// Inorder traversal
void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// Main function
int main() {
    struct Node* root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);

    printf("Inorder traversal: ");
    inorder(root);
    printf("\n");

    if (search(root, 40)) {
        printf("40 found in BST\n");
    } else {
        printf("40 not found\n");
    }

    return 0;
}`
            },
            "6.A": {
                "title": "Queue Using Arrays",
                "category": "Stack & Queue",
                "language": "c",
                "description": "Queue implementation with array",
                "code": `#include <stdio.h>
#define MAX 100

int queue[MAX];
int front = -1, rear = -1;

// Enqueue function
void enqueue(int data) {
    if (rear < MAX - 1) {
        if (front == -1) front = 0;
        queue[++rear] = data;
        printf("%d enqueued to queue\n", data);
    } else {
        printf("Queue Overflow\n");
    }
}

// Dequeue function
int dequeue() {
    if (front == -1 || front > rear) {
        printf("Queue Underflow\n");
        return -1;
    }
    int data = queue[front++];
    printf("%d dequeued from queue\n", data);
    return data;
}

// Main function
int main() {
    enqueue(10);
    enqueue(20);
    enqueue(30);
    dequeue();
    printf("Front element: %d\n", queue[front]);
    return 0;
}`
            },
            "6.B": {
                "title": "DFS Graph Traversal",
                "category": "Graph Algorithms",
                "language": "c",
                "description": "Depth-First Search traversal",
                "code": `#include <stdio.h>
#include <stdlib.h>
#define MAX 100

// Graph representation using adjacency list
struct Node {
    int vertex;
    struct Node* next;
};

struct Node* head[MAX];
int visited[MAX];

// Add edge
void addEdge(int src, int dest) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->vertex = dest;
    newNode->next = head[src];
    head[src] = newNode;
}

// DFS recursive function
void DFS(int vertex) {
    visited[vertex] = 1;
    printf("%d ", vertex);

    struct Node* temp = head[vertex];
    while (temp != NULL) {
        int adjVertex = temp->vertex;
        if (!visited[adjVertex]) {
            DFS(adjVertex);
        }
        temp = temp->next;
    }
}

// Main function
int main() {
    int V = 5;
    for (int i = 0; i < V; i++) visited[i] = 0;

    addEdge(0, 1);
    addEdge(0, 2);
    addEdge(1, 3);
    addEdge(2, 4);

    printf("DFS starting from vertex 0: ");
    DFS(0);
    printf("\n");

    return 0;
}`
            },
            "7.A": {
                "title": "Queue Using Linked List",
                "category": "Stack & Queue",
                "language": "c",
                "description": "Queue implementation with linked list",
                "code": `#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* front = NULL;
struct Node* rear = NULL;

// Enqueue function
void enqueue(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    if (rear == NULL) {
        front = rear = newNode;
    } else {
        rear->next = newNode;
        rear = newNode;
    }
    printf("%d enqueued to queue\n", data);
}

// Dequeue function
int dequeue() {
    if (front == NULL) {
        printf("Queue Underflow\n");
        return -1;
    }
    struct Node* temp = front;
    int data = temp->data;
    front = front->next;
    if (front == NULL) rear = NULL;
    free(temp);
    printf("%d dequeued from queue\n", data);
    return data;
}

// Main function
int main() {
    enqueue(10);
    enqueue(20);
    enqueue(30);
    dequeue();
    return 0;
}`
            },
            "7.B": {
                "title": "KMP Pattern Matching Algorithm",
                "category": "String Algorithms",
                "language": "c",
                "description": "Knuth-Morris-Pratt pattern matching",
                "code": `#include <stdio.h>
#include <string.h>

// Compute LPS (Longest Proper Prefix which is also Suffix)
void computeLPS(char* pat, int m, int* lps) {
    int len = 0;
    lps[0] = 0;
    int i = 1;
    while (i < m) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i++] = len;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
    }
}

// KMP search
void KMPSearch(char* txt, char* pat) {
    int n = strlen(txt);
    int m = strlen(pat);
    int lps[m];

    computeLPS(pat, m, lps);

    int i = 0, j = 0;
    while (i < n) {
        if (pat[j] == txt[i]) {
            i++;
            j++;
        }
        if (j == m) {
            printf("Found pattern at index %d\n", i - j);
            j = lps[j - 1];
        } else if (i < n && pat[j] != txt[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
}

// Main function
int main() {
    char txt[] = "ABABDABACDABABCABAB";
    char pat[] = "ABABCABAB";

    printf("Text: %s\n", txt);
    printf("Pattern: %s\n", pat);
    KMPSearch(txt, pat);

    return 0;
}`
            }
        };

        // Map category names to filter values
        const categoryMap = {
            'Data Structures': 'data-structures',
            'Sorting Algorithms': 'sorting-algorithms',
            'Stack & Queue': 'stack-queue',
            'Graph Algorithms': 'graph-algorithms',
            'String Algorithms': 'string-algorithms'
        };

        let currentFilter = 'all';
        let searchQuery = '';

        // Render codes
        function renderCodes() {
            const codeGrid = document.getElementById('codeGrid');
            const noResults = document.getElementById('noResults');
            const resultsCount = document.getElementById('resultsCount');

            codeGrid.innerHTML = '';
            let count = 0;

            Object.entries(codesData).forEach(([id, code]) => {
                const categoryFilter = categoryMap[code.category];
                const matchesFilter = currentFilter === 'all' || categoryFilter === currentFilter;
                const searchText = (code.title + ' ' + code.description + ' ' + code.category).toLowerCase();
                const matchesSearch = searchText.includes(searchQuery.toLowerCase());

                if (matchesFilter && matchesSearch) {
                    count++;
                    const codeCard = document.createElement('div');
                    codeCard.className = 'code-card';
                    codeCard.innerHTML = `
                        <div class="card-header">
                            <div class="card-title">${code.title}</div>
                            <div class="card-meta">
                                <span>${code.category}</span>
                            </div>
                        </div>
                        <div class="card-description">${code.description}</div>
                        <div class="card-code">
                            <code>${escapeHtml(code.code)}</code>
                        </div>
                        <div class="card-footer">
                            <button class="copy-btn" onclick="copyCode(this)">COPY CODE</button>
                        </div>
                    `;

                    // Store code in button for copying
                    codeCard.querySelector('.copy-btn').dataset.code = code.code;
                    codeGrid.appendChild(codeCard);
                }
            });

            if (count === 0) {
                codeGrid.style.display = 'none';
                noResults.style.display = 'block';
                resultsCount.textContent = '';
            } else {
                codeGrid.style.display = 'grid';
                noResults.style.display = 'none';
                resultsCount.textContent = `Showing ${count} code${count !== 1 ? 's' : ''}`;
            }
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy to clipboard
        window.copyCode = function(button) {
            const code = button.dataset.code;
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.textContent;
                button.textContent = 'COPIED!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        };

        // Event listeners
        document.getElementById('searchInput').addEventListener('input', (e) => {
            searchQuery = e.target.value;
            renderCodes();
        });

        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                renderCodes();
            });
        });

        // Initial render
        renderCodes();
    </script>
</body>
</html>
